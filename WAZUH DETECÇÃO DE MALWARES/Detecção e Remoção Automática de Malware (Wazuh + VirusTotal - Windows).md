
---
<h1 align="center">Detecção e Remoção Automática de Malware (Wazuh + VirusTotal - Windows)</h1>

<p align="center">
   <img width="48" height="48" alt="icon" src="https://github.com/user-attachments/assets/13e4a6e0-a11c-4822-918a-6a14e8e7cb8a" />
</p>

<div align="center">

  <img src="https://img.shields.io/badge/Target-Windows%2010%2F11-blue" alt="Windows Badge">
  <img src="https://img.shields.io/badge/Integration-VirusTotal-red" alt="VirusTotal Badge">
  <img src="https://img.shields.io/badge/Action-Auto%20Delete-red" alt="Action Badge">

</div>

---

## Contexto

Apenas detectar um vírus não é suficiente se a resposta demorar. Em cenários de ataque rápido, a **automatização** é essencial.

Este projeto configura o **Wazuh** para monitorar a pasta de Downloads em estações **Windows 10/11**. Novos arquivos têm seus hashes enviados automaticamente para a API do **VirusTotal**. Caso o arquivo seja identificado como malicioso, o Wazuh aciona uma **Resposta Ativa** que executa a deleção imediata do artefato usando um script Python seguro.

---

## Pré-requisitos

* **Wazuh Manager** (Linux) e **Wazuh Agent** (Windows) instalados e conectados.
* **Acesso à Internet**
* O servidor deve acessar **`www.virustotal.com` (porta 443)**.


* **Python 3.x** instalado no Windows.
* **Importante:** Marque a opção **"Add Python to PATH"** durante a instalação.


* **API Key do VirusTotal**.

---

## 1. Configuração do Monitoramento (Windows Agent)

Edite o arquivo de configuração no agente Windows:

**`C:\Program Files (x86)\ossec-agent\ossec.conf`**

Dentro do bloco `<syscheck>`, configure o monitoramento em tempo real para a pasta de Downloads (o `*` abrange todos os usuários):

```xml
<syscheck>
  <disabled>no</disabled>
  <frequency>300</frequency>
  <scan_on_start>yes</scan_on_start>

  <directories check_all="yes" realtime="yes">
    C:\Users\*\Downloads
  </directories>

  <ignore type="sregex">.log$|.tmp$</ignore>
</syscheck>

```

Reinicie o serviço do agente via PowerShell (Admin):

```powershell
Restart-Service -Name WazuhSvc

```

---

## 2. Configuração da Integração (Wazuh Manager)

No servidor Manager (Linux), edite o arquivo:

**`/var/ossec/etc/ossec.conf`**

Adicione a integração com o **VirusTotal**, vinculando ao grupo `syscheck`:

```xml
<integration>
  <name>virustotal</name>
  <api_key>SUA_API_KEY_AQUI</api_key>
  <group>syscheck</group>
  <alert_format>json</alert_format>
</integration>

```

---

## 3. Script de Remoção (Windows Agent)

No Windows, precisamos de dois arquivos: um script Python (a lógica segura) e um arquivo `.cmd` (o lançador).

### 3.1 Script Python (Seguro)

Crie o arquivo:

**`C:\Program Files (x86)\ossec-agent\active-response\bin\remove-threat.py`**

Este script inclui validações de segurança contra Links Simbólicos e streams NTFS.

```python
# Copyright (C) 2015-2025, Wazuh Inc.
# All rights reserved.

import os
import sys
import json
import datetime
import stat
import pathlib

if os.name == 'nt':
    LOG_FILE = "C:\\Program Files (x86)\\ossec-agent\\active-response\\active-responses.log"
else:
    LOG_FILE = "/var/ossec/logs/active-responses.log"

ADD_COMMAND = 0
DELETE_COMMAND = 1
CONTINUE_COMMAND = 2
ABORT_COMMAND = 3

OS_SUCCESS = 0
OS_INVALID = -1


class message:
    def __init__(self):
        self.alert = ""
        self.command = 0


def write_debug_file(ar_name, msg):
    with open(LOG_FILE, mode="a") as log_file:
        log_file.write(
            f"{datetime.datetime.now().strftime('%Y/%m/%d %H:%M:%S')} {ar_name}: {msg}\n"
        )


def setup_and_check_message(argv):
    input_str = ""
    for line in sys.stdin:
        input_str = line
        break

    msg_obj = message()

    try:
        data = json.loads(input_str)
    except ValueError:
        write_debug_file(argv[0], "Decoding JSON has failed, invalid input format")
        msg_obj.command = OS_INVALID
        return msg_obj

    msg_obj.alert = data
    command = data.get("command")

    if command == "add":
        msg_obj.command = ADD_COMMAND
    elif command == "delete":
        msg_obj.command = DELETE_COMMAND
    else:
        msg_obj.command = OS_INVALID
        write_debug_file(argv[0], f"Not valid command: {command}")

    return msg_obj


def send_keys_and_check_message(argv, keys):
    keys_msg = json.dumps({
        "version": 1,
        "origin": {
            "name": argv[0],
            "module": "active-response"
        },
        "command": "check_keys",
        "parameters": {
            "keys": keys
        }
    })

    write_debug_file(argv[0], keys_msg)

    print(keys_msg)
    sys.stdout.flush()

    input_str = ""
    while True:
        line = sys.stdin.readline()
        if line:
            input_str = line
            break

    try:
        data = json.loads(input_str)
    except ValueError:
        write_debug_file(argv[0], "Decoding JSON has failed, invalid input format")
        return OS_INVALID

    action = data.get("command")

    if action == "continue":
        return CONTINUE_COMMAND
    elif action == "abort":
        return ABORT_COMMAND
    else:
        write_debug_file(argv[0], "Invalid value of 'command'")
        return OS_INVALID


def secure_delete_file(filepath_str, ar_name):
    filepath = pathlib.Path(filepath_str)

    # Reject NTFS alternate data streams
    if "::" in filepath_str:
        raise Exception(f"Refusing to delete ADS or NTFS stream: {filepath_str}")

    # Reject symbolic links
    if os.path.islink(filepath):
        raise Exception(f"Refusing to delete symbolic link: {filepath}")

    attrs = os.lstat(filepath).st_file_attributes
    if attrs & stat.FILE_ATTRIBUTE_REPARSE_POINT:
        raise Exception(f"Refusing to delete reparse point: {filepath}")

    resolved_filepath = filepath.resolve()

    # Ensure it's a regular file
    if not resolved_filepath.is_file():
        raise Exception(f"Target is not a regular file: {resolved_filepath}")

    # Perform deletion
    os.remove(resolved_filepath)


def main(argv):
    write_debug_file(argv[0], "Started")

    msg = setup_and_check_message(argv)

    if msg.command < 0:
        sys.exit(OS_INVALID)

    if msg.command == ADD_COMMAND:
        alert = msg.alert["parameters"]["alert"]
        keys = [alert["rule"]["id"]]

        action = send_keys_and_check_message(argv, keys)

        if action != CONTINUE_COMMAND:
            if action == ABORT_COMMAND:
                write_debug_file(argv[0], "Aborted")
                sys.exit(OS_SUCCESS)
            else:
                write_debug_file(argv[0], "Invalid command")
                sys.exit(OS_INVALID)

        try:
            file_path = alert["data"]["virustotal"]["source"]["file"]

            if os.path.exists(file_path):
                secure_delete_file(file_path, argv[0])
                write_debug_file(
                    argv[0],
                    json.dumps(msg.alert) + " Successfully removed threat"
                )
            else:
                write_debug_file(argv[0], f"File does not exist: {file_path}")

        except OSError:
            write_debug_file(
                argv[0],
                json.dumps(msg.alert) + " Error removing threat"
            )
        except Exception as e:
            write_debug_file(
                argv[0],
                f"{json.dumps(msg.alert)}: Error removing threat: {str(e)}"
            )
    else:
        write_debug_file(argv[0], "Invalid command")

    write_debug_file(argv[0], "Ended")
    sys.exit(OS_SUCCESS)


if __name__ == "__main__":
    main(sys.argv)

```

### 3.2 Lançador Batch (.cmd)

Crie o arquivo na mesma pasta:

**`C:\Program Files (x86)\ossec-agent\active-response\bin\remove-threat.cmd`**

**Atenção:** Verifique o caminho do seu Python (`Get-Command python` no PowerShell).

```batch
@echo off
"C:\Users\SEU_USUARIO\AppData\Local\Programs\Python\Python311\python.exe" "C:\Program Files (x86)\ossec-agent\active-response\bin\remove-threat.py" %*

```

---

## 4. Ativar a Resposta Ativa (Wazuh Manager)

No arquivo **`/var/ossec/etc/ossec.conf`** do Manager:

Associe o comando à regra **87105 (VirusTotal – Malicious)**:

```xml
<command>
  <name>win-remove-threat</name>
  <executable>remove-threat.cmd</executable>
  <timeout_allowed>no</timeout_allowed>
</command>

<active-response>
  <command>win-remove-threat</command>
  <location>local</location>
  <rules_id>87105</rules_id>
</active-response>

```

Reinicie o Wazuh Manager:

```bash
systemctl restart wazuh-manager

```

---

## 5. Troubleshooting e Validação

### Verificar Logs de Resposta


Para acompanhar a execução em tempo real, abra o arquivo no Windows:

**`C:\Program Files (x86)\ossec-agent\active-response\active-responses.log`**

---

### Teste de Execução (EICAR)

No **PowerShell** do Windows, baixe o arquivo de teste na pasta monitorada:

```powershell
Invoke-WebRequest -Uri "https://secure.eicar.org/eicar.com" -OutFile "C:\Users\SEU_USUARIO\Downloads\jogo_falso.exe"

```

> ✅ O arquivo deverá ser **removido automaticamente em segundos** e uma entrada aparecerá no log de respostas ativas.
<p align="center">
   <img width="1497" height="203" alt="Captura de tela de 2026-01-28 21-14-18" src="https://github.com/user-attachments/assets/c6f5fbda-16a6-4509-b2f7-a2b6f22f1e30" />
</p>

---

## Próximos Passos

Após validar o funcionamento básico, considere evoluir a solução:

1. **Whitelist**
Implementar verificação de diretórios confiáveis para evitar falsos positivos.
2. **Dashboards Personalizados**
Criar visualizações no **Kibana/OpenSearch** filtrando pelo ID de regra 87105.
3. **Notificações**
Enviar alertas via **Slack, Discord ou Telegram** sempre que o script for acionado.
4. **Isolamento de Host**
Evoluir o script para bloquear a rede via `netsh` em caso de ameaças críticas.

---
